//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

import { ByteBuf } from "../core/bright/ByteBuf"

export namespace bmap {
    export enum Orientation {
        Unknown = 0,
        Orthogonal = 1,
        Isometric = 2,
        Staggered = 3,
        Hexagonal = 4,
    }
    }
    export namespace bmap {
    export enum RenderOrder {
        RightDown = 0,
        RightUp = 1,
        LeftDown = 2,
        LeftUp = 3,
    }
    }
    export namespace bmap {
    export enum LayerType {
        TileLayerType = 1,
        ObjectGroupType = 2,
        ImageLayerType = 4,
        GroupLayerType = 8,
    }
    }
    export namespace bmap {
    export enum StaggerAxis {
        StaggerX = 0,
        StaggerY = 1,
    }
    }
    export namespace bmap {
    export enum StaggerIndex {
        StaggerOdd = 0,
        StaggerEven = 1,
    }
    }
    
    
    export namespace bmap {
    export  class BMap  {
    
        constructor(_buf_: ByteBuf) {
            this.orientation = _buf_.ReadInt()
            this.renderorder = _buf_.ReadInt()
            this.width = _buf_.ReadInt()
            this.height = _buf_.ReadInt()
            this.tilewidth = _buf_.ReadInt()
            this.tileheight = _buf_.ReadInt()
            this.infinite = _buf_.ReadInt()
            if(_buf_.ReadBool()) { this.hexsidelength = _buf_.ReadInt() } else { this.hexsidelength = undefined }
            if(_buf_.ReadBool()) { this.staggeraxis = _buf_.ReadInt() } else { this.staggeraxis = undefined }
            if(_buf_.ReadBool()) { this.staggerindex = _buf_.ReadInt() } else { this.staggerindex = undefined }
            { this.tileset = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.TileSet; _e = new bmap.TileSet(_buf_); this.tileset.push(_e) } }
            { this.layer = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.Layer; _e = new bmap.Layer(_buf_); this.layer.push(_e) } }
        }
    
        readonly orientation: bmap.Orientation
        
        readonly renderorder: bmap.RenderOrder
        
        readonly width: number
        
        readonly height: number
        
        readonly tilewidth: number
        
        readonly tileheight: number
        
        readonly infinite: number
        
        readonly hexsidelength: number|undefined
        
        readonly staggeraxis: bmap.StaggerAxis|undefined
        
        readonly staggerindex: bmap.StaggerIndex|undefined
        
        readonly tileset: bmap.TileSet[]
        
        readonly layer: bmap.Layer[]
        
    }
    }
    
    export namespace bmap {
    export  class TileSet  {
    
        constructor(_buf_: ByteBuf) {
            if(_buf_.ReadBool()) { this.firstgid = _buf_.ReadInt() } else { this.firstgid = undefined }
            this.name = _buf_.ReadString()
            this.tilewidth = _buf_.ReadInt()
            this.tileheight = _buf_.ReadInt()
            this.spacing = _buf_.ReadInt()
            this.margin = _buf_.ReadInt()
            this.tilecount = _buf_.ReadInt()
            this.columns = _buf_.ReadInt()
            if(_buf_.ReadBool()) { this.tileoffset = new bmap.TileOffset(_buf_) } else { this.tileoffset = undefined }
            if(_buf_.ReadBool()) { this.grid = new bmap.Grid(_buf_) } else { this.grid = undefined }
            if(_buf_.ReadBool()) { this.image = new bmap.Image(_buf_) } else { this.image = undefined }
            { this.tiles = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.Tile; _e = new bmap.Tile(_buf_); this.tiles.push(_e) } }
        }
    
        readonly firstgid: number|undefined
        
        readonly name: string
        
        readonly tilewidth: number
        
        readonly tileheight: number
        
        readonly spacing: number
        
        readonly margin: number
        
        readonly tilecount: number
        
        readonly columns: number
        
        readonly tileoffset: bmap.TileOffset|undefined
        
        readonly grid: bmap.Grid|undefined
        
        readonly image: bmap.Image|undefined
        
        readonly tiles: bmap.Tile[]
        
    }
    }
    
    export namespace bmap {
    export  class TileOffset  {
    
        constructor(_buf_: ByteBuf) {
            this.x = _buf_.ReadInt()
            this.y = _buf_.ReadInt()
        }
    
        readonly x: number
        
        readonly y: number
        
    }
    }
    
    export namespace bmap {
    export  class Grid  {
    
        constructor(_buf_: ByteBuf) {
            this.orientation = _buf_.ReadInt()
            this.width = _buf_.ReadInt()
            this.height = _buf_.ReadInt()
        }
    
        readonly orientation: bmap.Orientation
        
        readonly width: number
        
        readonly height: number
        
    }
    }
    
    export namespace bmap {
    export  class Image  {
    
        constructor(_buf_: ByteBuf) {
            this.source = _buf_.ReadString()
            this.width = _buf_.ReadInt()
            this.height = _buf_.ReadInt()
        }
    
        readonly source: string
        
        readonly width: number
        
        readonly height: number
        
    }
    }
    
    export namespace bmap {
    export  class Tile  {
    
        constructor(_buf_: ByteBuf) {
            this.id = _buf_.ReadInt()
            if(_buf_.ReadBool()) { this.image = new bmap.Image(_buf_) } else { this.image = undefined }
            if(_buf_.ReadBool()) { this.objs = new bmap.Objs(_buf_) } else { this.objs = undefined }
            if(_buf_.ReadBool()) { this.anis = new bmap.Anis(_buf_) } else { this.anis = undefined }
        }
    
        readonly id: number
        
        readonly image: bmap.Image|undefined
        
        readonly objs: bmap.Objs|undefined
        
        readonly anis: bmap.Anis|undefined
        
    }
    }
    
    export namespace bmap {
    export  class Objs  {
    
        constructor(_buf_: ByteBuf) {
            { this.objlist = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.ObjectItem; _e = new bmap.ObjectItem(_buf_); this.objlist.push(_e) } }
        }
    
        readonly objlist: bmap.ObjectItem[]
        
    }
    }
    
    export namespace bmap {
    export  class ObjectItem  {
    
        constructor(_buf_: ByteBuf) {
            this.id = _buf_.ReadInt()
            if(_buf_.ReadBool()) { this.gid = _buf_.ReadInt() } else { this.gid = undefined }
            this.x = _buf_.ReadInt()
            this.y = _buf_.ReadInt()
            if(_buf_.ReadBool()) { this.width = _buf_.ReadInt() } else { this.width = undefined }
            if(_buf_.ReadBool()) { this.height = _buf_.ReadInt() } else { this.height = undefined }
            { this.polygon = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.Point; _e = new bmap.Point(_buf_); this.polygon.push(_e) } }
            { this.polyline = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.Point; _e = new bmap.Point(_buf_); this.polyline.push(_e) } }
        }
    
        readonly id: number
        
        readonly gid: number|undefined
        
        readonly x: number
        
        readonly y: number
        
        readonly width: number|undefined
        
        readonly height: number|undefined
        
        readonly polygon: bmap.Point[]
        
        readonly polyline: bmap.Point[]
        
    }
    }
    
    export namespace bmap {
    export  class Point  {
    
        constructor(_buf_: ByteBuf) {
            this.x = _buf_.ReadInt()
            this.y = _buf_.ReadInt()
        }
    
        readonly x: number
        
        readonly y: number
        
    }
    }
    
    export namespace bmap {
    export  class Anis  {
    
        constructor(_buf_: ByteBuf) {
            { this.anilist = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.Point; _e = new bmap.Point(_buf_); this.anilist.push(_e) } }
        }
    
        readonly anilist: bmap.Point[]
        
    }
    }
    
    export namespace bmap {
    export  class Layer  {
    
        constructor(_buf_: ByteBuf) {
            this.type = _buf_.ReadInt()
            this.id = _buf_.ReadInt()
            this.name = _buf_.ReadString()
            if(_buf_.ReadBool()) { this.x = _buf_.ReadInt() } else { this.x = undefined }
            if(_buf_.ReadBool()) { this.y = _buf_.ReadInt() } else { this.y = undefined }
            this.visible = _buf_.ReadInt()
            this.locked = _buf_.ReadInt()
            this.opacity = _buf_.ReadFloat()
            this.tintcolor = _buf_.ReadString()
            this.offsetx = _buf_.ReadInt()
            this.offsety = _buf_.ReadInt()
            if(_buf_.ReadBool()) { this.image = new bmap.Image(_buf_) } else { this.image = undefined }
            if(_buf_.ReadBool()) { this.ldata = new bmap.LayerData(_buf_) } else { this.ldata = undefined }
            { this.objs = []; for(let i = 0, n = _buf_.ReadSize() ; i < n ; i++) { let _e :bmap.ObjectItem; _e = new bmap.ObjectItem(_buf_); this.objs.push(_e) } }
        }
    
        readonly type: bmap.LayerType
        
        readonly id: number
        
        readonly name: string
        
        readonly x: number|undefined
        
        readonly y: number|undefined
        
        readonly visible: number
        
        readonly locked: number
        
        readonly opacity: number
        
        readonly tintcolor: string
        
        readonly offsetx: number
        
        readonly offsety: number
        
        readonly image: bmap.Image|undefined
        
        readonly ldata: bmap.LayerData|undefined
        
        readonly objs: bmap.ObjectItem[]
        
    }
    }
    
    export namespace bmap {
    export  class LayerData  {
    
        constructor(_buf_: ByteBuf) {
            this.bdata = _buf_.ReadString()
        }
    
        readonly bdata: string
        
    }
    }
    